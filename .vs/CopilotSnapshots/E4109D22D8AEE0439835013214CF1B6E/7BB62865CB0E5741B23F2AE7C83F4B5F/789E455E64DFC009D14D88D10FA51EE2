namespace gravity
{
    public class Ball
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double VelocityX { get; set; }
        public double VelocityY { get; set; }
        public int Size { get; set; }
        public double Mass { get; private set; }
        public Color BallColor { get; set; }
        public List<PointF> Trail { get; private set; }
        private const int MAX_TRAIL_LENGTH = 50;

        public Ball(double x, double y, int size, Color color)
        {
            X = x;
            Y = y;
            Size = size;
            BallColor = color;
            VelocityX = 0;
            VelocityY = 0;
            Trail = new List<PointF>();
            
            Mass = (size / 2.0) * (size / 2.0) * Math.PI / 100.0;
        }

        public void ApplyGravity(List<Block> attractors, double gravityStrength, double maxVelocity)
        {
            if (attractors.Count == 0) return;

            double totalForceX = 0;
            double totalForceY = 0;

            foreach (var block in attractors)
            {
                double dx = block.X - X;
                double dy = block.Y - Y;
                double distance = Math.Sqrt(dx * dx + dy * dy);

                if (distance > 1)
                {
                    double force = gravityStrength * Mass / distance;
                    totalForceX += (dx / distance) * force;
                    totalForceY += (dy / distance) * force;
                }
            }

            VelocityX += totalForceX;
            VelocityY += totalForceY;

            LimitVelocity(maxVelocity);
        }

        // 球與球之間的排斥力
        public void ApplyRepulsion(List<Ball> otherBalls, double repulsionStrength)
        {
            foreach (var other in otherBalls)
            {
                if (other == this) continue;

                double dx = X - other.X; // 注意:排斥力方向相反
                double dy = Y - other.Y;
                double distance = Math.Sqrt(dx * dx + dy * dy);

                // 只在球很接近時才產生排斥力
                double repulsionRange = (Size + other.Size) * 1.5;
                
                if (distance > 1 && distance < repulsionRange)
                {
                    // 排斥力公式:距離越近,力越大
                    double force = repulsionStrength / (distance * distance);
                    
                    VelocityX += (dx / distance) * force;
                    VelocityY += (dy / distance) * force;
                }
            }
        }

        private void LimitVelocity(double maxVelocity)
        {
            double velocity = Math.Sqrt(VelocityX * VelocityX + VelocityY * VelocityY);
            if (velocity > maxVelocity)
            {
                VelocityX = (VelocityX / velocity) * maxVelocity;
                VelocityY = (VelocityY / velocity) * maxVelocity;
            }
        }

        public void UpdatePosition(double timeScale = 1.0)
        {
            double newX = X + VelocityX * timeScale;
            double newY = Y + VelocityY * timeScale;

            double movementDistance = Math.Sqrt(
                Math.Pow(newX - X, 2) + 
                Math.Pow(newY - Y, 2)
            );

            if (movementDistance > 0.5)
            {
                Trail.Add(new PointF((float)X, (float)Y));

                if (Trail.Count > MAX_TRAIL_LENGTH)
                {
                    Trail.RemoveAt(0);
                }
            }

            X = newX;
            Y = newY;
        }

        public bool IsOutOfBounds(int width, int height)
        {
            return X < -Size * 2 ||
                   X > width + Size ||
                   Y < -Size * 2 ||
                   Y > height + Size;
        }

        public void Draw(Graphics g)
        {
            if (Trail.Count > 1)
            {
                using (Pen trailPen = new Pen(Color.FromArgb(100, BallColor), 1))
                {
                    for (int i = 0; i < Trail.Count - 1; i++)
                    {
                        int alpha = (int)(100 * ((float)i / Trail.Count));
                        trailPen.Color = Color.FromArgb(alpha, BallColor);
                        g.DrawLine(trailPen, Trail[i], Trail[i + 1]);
                    }
                }
            }

            using (SolidBrush brush = new SolidBrush(BallColor))
            {
                g.FillEllipse(brush, (float)X, (float)Y, Size, Size);
            }
        }
    }
}